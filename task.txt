/*
Данная задача является бонусной высокого уровня, она гарантирует вам +1.5 балла к оценке семинариста при чистом решении к 10-бальной оценке в конце
семестра в случае, если ваша оценка на тот момент будет >= уд(3).

ВСВЯЗИ С КАРАНТИННЫМИ МЕРОПРИЯТИЯМИ И ОТМЕНОЙ ПОЛУСЕМЕСТРОВОЙ КОНТРОЛЬНОЙ, АНАЛОГИЧНЫМ ОБРАЗОМ ЗАДАЧА БУДЕТ ВЛИЯТЬ И НА ОЦЕНКУ КР1, УКАЗАННУЮ В БРС.

Тем не менее дедлайн для отправки решений - 16 марта, 23:00.

Решать данную задачу на интерпретируемых языках не имеет смысла, так как они дадут просадку производительности "из коробки"
Желательно - С++, но готов рассматривать Go, Rust, C.
*/

/*
    Хотя в нашем курсе класс задач и языков NP рассматривается как нечто трудное,
    что не стоит даже пытаться решать за полином, на практике подобные задачи решать все же приходится.
    Обычно используются различные эвристики, которые все так же плохи в худшем случае, как и полный перебор,
    но способные на большей части возможных входов давать быстрый ответ.

    В этот раз мы предлагаем вам решить задачу из биоинформатики, а именно по набору строк определить длину наименьшей строки, содержащие все 
    строки набора в качестве подстрок. Например для набора [abba, aca, bac, aa] одной из наименьших общих надстрок будет abbacaa.
    
    Мы предалагаем вам реализовать два подхода к решению данной задачи.
    
    1. Приближенное решение алгоритмом Блюма-Янга-Ли-Тромпа-Яннакакиса https://habr.com/ru/post/201656/
    2. Точное решение. Например, можно достаточно эффективно свести данную задачу к задаче коммивоежера.
    
    Так же в этой задаче от вас будет требоваться некоторый более серьезный подход к оформлению кода.
    
    0. Код должен быть представлен в виде github репозитория
    1. Разбиение кода на модули, понятное наимернование переменных, функции и классы должны именоваться в стиле CamelCase, переменные - snake_case.
        Рукомендуется использование ClangFormat или любых других автоматических инструментов контроля стиля
    2. Использование автоматической системы сборки, например Make и CMake
    3. Написание тестов: несколько случаев графа должны проверяться автоматически. Разберитесь с одним из двух фреймворков 
        для С++ google-test или catch. При выборе другого языка выбор фремфорка остается за вами. 
        Пример: https://github.com/Avi2011class/AdvancedContainers
    4. Использование систем непрерывной интеграции (CI), например https://travis-ci.org/. Вообще, travis должен стать вашим другом 
        при написании чего-то, содержащего более 100 строк кода.
        Пример: https://github.com/Avi2011class/Dot11Monitoring/blob/master/.travis.yml
*/

/*
    При написании кода вам, скорее всего, понадобится работать с взвешенными графами
    Граф стоит хранить в отдельном классе для обеспечения архитектуры и читаемости кода.
*/

#include <vector>
#include <cstdint>

class Graph {
public:
    Graph(size_t n_vertex);
    void AddEdge(size_t from, size_t to, size_t length);

    ... GetEdgesFrom(size_t from) const;
};



/*
    Задача, демонстрирующая применение идеи MITM и снижения основания экспоненты при переборе пространства решения 
    NP-сложной задачи

    Условие:
        На вход программе подаются N целых чисел, нужно найти два непересекающихся непустых подмножества этих чисел таких,
        что суммы чисел каждого подмножества будут равны.

    Решение в лоб:
        Рассмотрим все N-значные числа в троичной системе исчисления, в каждом из них 0 на i позиции будет означать, что i число не взять,
        1 - что оно принадлежит первому подмножеству, 2 - второму. Для каждого числа проверим условие, что соответствующие подмножества не пусты и
        их суммы совпадают. Оценка сложности снизу -- \Omega(3^N), как перебор количества разбиений. На самом деле все еще немного хуже,
        так как для каждого разбиения нужно считать сумму.

    Решение по MITM:
        1. Разобьем числа на две группы по N/2. (если N нечетно, то группы будут отличаться размерном на 1)
        2. Для каждой группы построим аналогично предыдущему решению 3^(N/2) разбиений и вычислим их суммы, причем
            в этот раз включим в перебор и такие разбиения, где одно из множеств (а может и оба) будет пустым.
            Сохраним не обе суммы, а лишь только разность между ними вместе с описанием разбиений в массивы A и B.
            (А хранит пары <разбиение, разность сумм подмножеств> для первой половины всех чисел, B - для второй,
            итого их размеры в районе 3^(N/2))

        3. Отсортируем A и B по возрастанию и за линейное по их сумме длин время будем перебирать все пары a[i] \in A, b[i] \in B, таких,
            что a[i] == b[i].

        4. Чуть-чуть подумаем над процессом из п. 3 и выведем ответ.

        Идея: Если есть два равных числа в массивах, то a[l] = \sum_i A[s_i] - \sum_j A[k_j], то b[q] = \sum_r B[p_r] - \sum_t B[u_t],
            Тогда \sum_i A[s_i] + \sum_t B[u_t] = \sum_r B[p_r] + \sum_j A[k_j] - мы нашли два равных по сумме непересекающихся подмножества.
            Проверка на непустоту осуществляется отдельно.
*/
